Traffic Management
---
 
Istio의 트래픽 라우팅 규칙을 사용하면 
서비스 간의 트래픽 흐름과 API 호출을 쉽게 제어 할 수 있다.   
Istio는 Circuit Breaker, Timeout 및 Retry와 같은 서비스 수준 속성 구성을 단순화하고   
A/B 테스트, 카나리아 Roll out 및 백분율 기반 트래픽 분할을 통한   
단계적 출시와 같은 중요한 작업을 쉽게 설정할 수 있다.   
또한 종속 서비스 또는 네트워크의 장애에 대비하여   
애플리케이션을 보다 강력하게 만드는 데 도움이 되는 기본 장애복구 기능을 제공한다.   
    
stio의 트래픽 관리 모델은   
서비스와 함께 배포 된 Envoy 프록시에 의존한다.   
메시 서비스에 주고 받는 모든 트래픽 (데이터 평면 트래픽)은   
Envoy를 통해 프록시 되므로   
서비스를 변경하지 않고도 메시 주변의 트래픽을 쉽게 지시하고 제어 할 수 있다.   
이 가이드에 설명 된 기능의 작동 방식에 대한 자세한 내용은   
아키텍처 개요에서 Istio의 트래픽 관리 구현에 대해 자세히 알아볼 수 있다.   
이 안내서의 나머지 부분에서는 Istio의 트래픽 관리 기능을 소개한다.   


Istio 트래픽 관리 소개
---

메시 내에서 트래픽을 전달하려면   
Istio가 모든 엔드 포인트의 위치와 서비스가 속한 서비스를 알아야 한다.    
자체 서비스 레지스트리를 채우려면 Istio가 서비스 검색 시스템에 연결한다.  
   
예를 들어 Kubernetes 클러스터에 Istio를 설치 한 경우,   
Istio는 해당 클러스터의 서비스 및 엔드 포인트를 자동으로 감지한다.   

Envoy 프록시는   
이 서비스 레지스트리를 사용하여 트래픽을 관련 서비스로 보낼 수 있다.    

대부분의 마이크로 서비스 기반 애플리케이션에는 서비스 트래픽을 처리하기 위해   
각 서비스 워크로드의 여러 인스턴스가 있다 ( 때로는 로드 밸런싱 풀 이라고도 한다)    
Envoy 프록시는 기본적으로 Round Robin 모델을 사용하여,   
각 서비스의 로드 밸런싱 풀에 트래픽을 분배한다.   
이 모델에서는 요청이 각 풀 멤버에게 차례로 전송되어   
각 서비스 인스턴스가 요청을 받으면 풀의 맨 위로 돌아간다.   
   
Istio의 기본 서비스 검색 및 로드 밸런싱은 동작하는 서비스 메시를 제공하지만,   
Istio가 할 수있는 모든 것과는 다소 거리가 있다.    
많은 경우 메쉬 트래픽에 발생하는 상황을 보다 세밀하게 제어 할 수 있다.   
특정 비율의 트래픽을 A/B 테스트의 일부로 (새로운 버전의 서비스로) 보내거나   
특정 서비스 인스턴스 하위 집합의 트래픽에 다른로드 밸런싱 정책을 적용 할 수 있다.   
메시로 들어 오거나 나가는 트래픽에 특수 규칙을 적용하거나   
메시의 외부 종속성을 서비스 레지스트리에 추가 할 수도 있다.   
Istio의 트래픽 관리 API를 사용하여 Istio에 자체 트래픽 구성을 추가하여이 모든 작업을 수행 할 수 있다.   
   
다른 Istio 구성과 마찬가지로 API는 Kubernetes 사용자 지정 리소스 정의 (CRD)를 사용하여 지정되며,    
예에서 볼 수 있듯이 YAML을 사용하여 구성 할 수 있다.   
이 가이드의 나머지 부분에서는 각 트래픽 관리 API 리소스와 리소스로 수행 할 수있는 작업에 대해 설명한다.   
이러한 리소스는 다음과 같습니다   
   
* 가상 서비스
* 대상 규칙
* 게이트웨이
* 서비스 항목
* 사이드카
   
이 가이드는 또한 API 리소스에 내장된 일부 네트워크 탄력성 및 테스트 기능에 대한 개요를 제공한다.   
   
가상 서비스
---

가상 서비스는 대상 규칙과 함께 Istio의 트래픽 라우팅 기능의 핵심 구성요소이다.    
가상 서비스를 사용하면   
Istio 및 사용자 플랫폼에서 제공하는 기본 연결 및 검색을 기반으로   
요청이 Istio 서비스 메시 내의 서비스로 라우팅되는 방식을 구성 할 수 있다.    
각 가상 서비스는 순서대로 평가되는 일련의 라우팅 규칙으로 구성되어 있어    
Istio가 각각의 지정된 요청을   
가상 서비스에 대한 메시 내의 특정 실제 대상과 일치시킬 수 있다.   
메시는 여러 가상 서비스를 요구하거나 사용 사례에 따라 필요하지 않을 수 있다.
   
가상 서비스를 사용하는 이유
---
가상 서비스는 Istio의 트래픽 관리를 "유연하고 강력하게 만드는 데" 핵심적인 역할을 한다.   
대상 워크로드에서는 클라이언트로부터의 요청 위치를 강력하게 분리하여 이를 수행한다.   
가상 서비스는   
트래픽을 해당 워크로드로 보내기 위해   
다른 트래픽 라우팅 규칙을 지정하기 위한 다양한 방법을 제공한다.   
   
이것이 왜 그렇게 유용한가요?   
가상 서비스가 없으면   
Envoy는 모든 서비스 인스턴스간에 Round Robin 부하 분산을 사용하여 트래픽을 분산시킨다.   
워크로드에 대해 알고있는 내용으로, 이 동작을 개선 할 수 있다.   
예를 들어, 일부는 다른 버전을 나타낼 수 있다.   
이 기능은   
A/B 테스트에서 유용 할 수 있다.   
A/B 테스트에서는 여러 서비스 버전에서 백분율을 기반으로 트래픽 경로를 구성하거나   
내부 사용자의 트래픽을 특정 인스턴스 집합으로 보낼 수 있다.

가상 서비스를 사용하면   
하나 이상의 호스트 이름에 대한 트래픽 동작을 지정할 수 있다.   
가상 서비스의 트래픽을 적절한 대상으로 보내는 방법을 Envoy에게 알려주는 라우팅 서비스를 가상 서비스에서 사용한다.   
경로 목적지는 동일한 서비스 또는 완전히 다른 서비스의 버전 일 수 있다.   
   
일반적인 사용 사례는   
서비스 하위 집합으로 지정된 다른 버전의 서비스로 트래픽을 보내는 것이다.   
클라이언트는 단일 엔터티인 것처럼 가상 서비스 호스트에 요청을 보내고   
Envoy는 가상 서비스 규칙에 따라 트래픽을 다른 버전으로 라우팅한다.   
예를 들어 "20%가 새로운 버전으로 이동" 또는 "이 사용자들로부터의 요청은 버전 2”로 간다.   
예를 들어 새로운 서비스 버전으로 전송되는 트래픽의 비율을 점차적으로 증가시키는   
카나리아 롤아웃을 만들 수 있다.   
트래픽 라우팅은 인스턴스 배포와 완전히 별개이므로   
새 서비스 버전을 구현하는 인스턴스 수는 트래픽 라우팅을 전혀 참조하지 않고도   
트래픽로드에 따라 확장 및 축소 할 수 있다.    
반대로 Kubernetes와 같은 컨테이너 오케스트레이션 플랫폼은   
인스턴스 스케일링을 기반으로 한   
트래픽 분배만 지원하므로 빠르게 복잡해진다.   
Istio를 사용하여 카나리아 배포에서   
가상 서비스가 카나리아 배포를 지원하는 방법에 대해 자세히 읽을 수 있다.  
   
가상 서비스를 통해 다음을 수행 할 수 있습니다.   

* 단일 가상 서비스를 통해 여러 애플리케이션 서비스를 처리할 수 있다. 
예를 들어 메시가 Kubernetes를 사용하는 경우  
특정 네임 스페이스의 모든 서비스를 처리하도록 가상 서비스를 구성 할 수 있다.   
단일 가상 서비스를 여러 "실제"서비스에 매핑하면 서비스 소비자가 전환에 적응할 필요 없이   
단일 응용 프로그램을 개별 마이크로 서비스로 구성된 복합 서비스로 쉽게 전환 할 수 있다.   
라우팅 규칙은 "monoli.com의 이러한 URI에 대한 호출은 마이크로 서비스 A로 이동"등을 지정할 수 있다.   
아래 예제 중 하나에서 이것이 어떻게 작동하는지 볼 수 있습니다.
   
* 게이트웨이와 결합하여 트래픽 규칙을 구성하여 수신 및 송신 트래픽을 제어하십시오.   
   
경우에 따라 서비스 하위 집합을 지정하는 위치에서 이러한 기능을 사용하도록 대상 규칙을 구성해야 한다.    
별도의 개체에 서비스 하위 집합 및 기타 대상별 정책을 지정하면   
가상 서비스간에 이를 명확하게 재사용 할 수 있다.   
다음 섹션에서 대상 규칙에 대한 자세한 내용을 확인할 수 있다.

가상 서비스 예제
---

다음 가상 서비스는 특정 사용자의 요청에 따라 요청을 다른 버전의 서비스로 라우팅한다.   

<pre>
<code>
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews
spec:
  hosts:
  - reviews
  http:
  - match:
    - headers:
        end-user:
          exact: jason
    route:
    - destination:
        host: reviews
        subset: v2
  - route:
    - destination:
        host: reviews
        subset: v3
</code>
</pre>
